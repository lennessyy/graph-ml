= Same Community

.Supported Graph Characteristics
****
[cols='1']
|===
^|Unweighted edges
^|Directed edges
^|Undirected edges
^|Homogeneous vertex types
^|Heterogeneous vertex types
|===

Algorithm link: link:https://github.com/tigergraph/gsql-graph-algorithms/tree/master/algorithms/Topological%20Link%20Prediction/same_community[Same Community]


****

This algorithm takes two vertices as input, returning 1 if the two vertices are in the same community, and returning 0 if they are not in the same community.

== Notes

The algorithm assumes that community detection has already completed and that a community ID is stored in an integer attribute on each vertex.

This algorithm ignores edge weights.

== Specifications
[,gsql]
----
CREATE QUERY tg_same_community(VERTEX a, VERTEX b, STRING
    communityAttribute)
----

=== Time complexity
The algorithm has a time complexity of stem:[O(1)].

== Parameters
[cols="1,1,1"]
|===
|Name | Description | Data type

| `a`
|  A vertex.
|  `VERTEX`

| `b`
| A vertex.
| `VERTEX`

| `communityAttribute`
| The community attribute used to store a vertex's community ID.
| `STRING`
|===


== Return value

* Returns 1 if the two vertices are in the same community.
* Returns 0 if the two vertices are not in the same community.

== Example
Suppose we have the following vertices:

image::same-community-ex.png[]

Their community IDs were generated by running the weakly connected component algorithm on the graph. If we run the algorithm between Kevin and Jenny, we get 1 because the two vertices are in the same community as indicated by their `community` attribute:

[tabs]
====
Query::
+
--
[,gsql]
----
RUN QUERY tg_same_community (("Jenny", "person"), ("Kevin", "person"), "community")
----
--
Result::
+
--
[,json]
----
{
  "error": false,
  "message": "",
  "version": {
    "schema": 2,
    "edition": "enterprise",
    "api": "v2"
  },
  "results": [{"1": 1}]
}
----
--
====


