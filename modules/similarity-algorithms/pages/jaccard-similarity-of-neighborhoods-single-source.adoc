= Jaccard Similarity of Neighborhoods (Single Source)
:stem: latexmath

The Jaccard index measures the relative overlap between two sets. To compare two vertices by Jaccard similarity, first select a set of values for each vertex. For example, a set of values for a Person could be the cities the Person has lived in. Then the Jaccard index is computed for the two vectors.

The Jaccard index of two sets A and B is defined as follows:

[stem]
++++
Jaccard(A,B)=\frac{|A \cap B|}{|A \cup B|}
++++

The value ranges from 0 to 1. If A and B are identical, then Jaccard(A, B) = 1. If both A and B are empty, we define the value to be 0.

== Specifications

In the current

[,erlang]
----
tg_jaccard_nbor_ss (VERTEX source, STRING e_type, STRING rev_e_type,  INT top_k = 100,
  BOOL print_accum = TRUE, STRING similarity_edge_type = "",STRING file_path = "")
----+++<table>++++++<thead>++++++<tr>++++++<th style="text-align:left">++++++<b>+++Characteristic+++</b>++++++</th>+++
      +++<th style="text-align:left">+++Value+++</th>++++++</tr>++++++</thead>+++
  +++<tbody>++++++<tr>++++++<td style="text-align:left">+++Result+++</td>+++
      +++<td style="text-align:left">++++++<p>+++The top +++<em>+++k+++</em>+++ vertices in the graph that have the highest similarity
          scores, along with their scores.+++</p>+++
        +++<p>+++The result is available in three forms:+++</p>+++
        +++<ul>++++++<li>+++streamed out in JSON format+++</li>+++
          +++<li>+++written to a file in tabular format, or+++</li>+++
          +++<li>+++stored as a vertex attribute value.+++</li>++++++</ul>++++++</td>++++++</tr>+++
    +++<tr>++++++<td style="text-align:left">+++Input Parameters+++</td>+++
      +++<td style="text-align:left">++++++<ul>++++++<li>++++++<code>+++SET<STRING> v_type+++</code>+++: Vertex type to calculate similarity
            score for+++</li>+++
          +++<li>++++++<code>+++SET<STRING> e_type+++</code>+++: Edge type to traverse+++</li>+++
          +++<li>++++++<code>+++SET<STRING> re_type+++</code>+++: Reverse edge type to traverse+++</li>+++
          +++<li>++++++<code>+++INT top_k+++</code>+++: the number of vertex pairs with the highest similarity
            scores to return+++</li>+++
          +++<li>++++++<code>+++BOOL print_accum+++</code>+++: Boolean value that decides whether to output
            to console+++</li>+++
          +++<li>++++++<code>+++STRING similarity_edge+++</code>+++: If provided, the similarity score
            will be saved to this edge+++</li>+++
          +++<li>++++++<code>+++STRING filepath:+++</code>+++If provided, the algorithm will output to
            the file path in CSV format+++</li>++++++</ul>++++++</td>++++++</tr>+++
    +++<tr>++++++<td style="text-align:left">+++Result Size+++</td>+++
      +++<td style="text-align:left">++++++<code>+++top_k+++</code>++++++</td>++++++</tr>+++
    +++<tr>++++++<td style="text-align:left">+++Time Complexity+++</td>+++
      +++<td style="text-align:left">+++O(D{caret}2), D = outdegree of vertex v+++</td>++++++</tr>+++
    +++<tr>++++++<td style="text-align:left">+++Graph Types+++</td>+++
      +++<td style="text-align:left">+++Undirected or directed edges, unweighted edges+++</td>++++++</tr>++++++</tbody>++++++</table>+++

The algorithm will not output more than K vertices, so the algorithm may arbitrarily choose to output one vertex over another if there are tied similarity scores.

== Example

Using the movie graph, we run `jaccard_nbor_ss("Neil", 5)`:

[,text]
----
[
  {
    "@@result_topK": [
      {
        "vertex1": "Neil",
        "vertex2": "Kat",
        "score": 0.5
      },
      {
        "vertex1": "Neil",
        "vertex2": "Kevin",
        "score": 0.4
      },
      {
        "vertex1": "Neil",
        "vertex2": "Jing",
        "score": 0.2
      }
    ]
  }
]
----

If the source vertex (person) doesn't have any common neighbors (movies) with any other vertex (person), such as Elena in our example, the result will be an empty list:

[,text]
----
[
  {
    "@@result_topK": []
  }
]
----
